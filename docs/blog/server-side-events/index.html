<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <link rel="stylesheet" href="https://malnossi.github.io/pico.min.css">
    <link rel="stylesheet" href="https://malnossi.github.io/style.css">
    <script src="https://cdnapp.websitepolicies.net/widgets/cookies/mzad7vzz.js" defer></script>
    <title>
Mohamed Nossirat | Pushing real-time updates to clients with Server-Sent Events (SSEs)
</title>
</head>
<style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');

    :root {
        --pico-font-family: "IBM Plex Serif", serif;
    }
</style>

<body>
    <main class="container">
        <nav>
  <ul>
    <li><strong>Mohamed Nossirat</strong></li>
  </ul>
  <ul>
    <li><a href="/" class="contrast">Home</a></li>
    <li><a href="/blog" class="contrast">Blog</a></li>
  </ul>
</nav>
<script>
  document.addEventListener('DOMContentLoaded', () => {

    // Get all "navbar-burger" elements
    const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

    // Add a click event on each of them
    $navbarBurgers.forEach(el => {
      el.addEventListener('click', () => {

        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');

      });
    });

  });
</script>
        
<figure class="image is-16by9">
  <img src="/sse-events.png" alt="Placeholder image" style="border-radius: 0.5rem;" width="100%"/>
</figure>
<div style="text-align: center; align-content: center; margin-top: 40px;">
  <h1>Pushing real-time updates to clients with Server-Sent Events (SSEs)</h1>
  
  <a class="tag is-link is-hoverable" href="/tags/python">#Python</a>
  
  <a class="tag is-link is-hoverable" href="/tags/fastapi">#FastApi</a>
  
  <a class="tag is-link is-hoverable" href="/tags/javascript">#Javascript</a>
  
</div>
<div>
  <h2 id="introduction"><a class="zola-anchor" href="#introduction" aria-label="Anchor link for: introduction">Introduction</a></h2>
<p>In multi-page web apps, there’s a pretty common flow that comes up:</p>
<p>A user loads a specific page or hits a button that kicks off a long-running task.
On the backend, a background worker grabs that task and starts processing it asynchronously.
Meanwhile, the page stays put—it shouldn't reload or block while all this is going on.
As the task runs, the server needs a way to keep the client updated with the status in real time.
Then once it’s done, the client should display a success or error message based on the result.</p>
<p>Now, the go-to tool when you need real-time, bidirectional communication is usually <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>. But in this case, it’s actually a one-way street: the client triggers something, and then it’s the server pushing updates back as the background job progresses.</p>
<p>Personally, when I’m working in <a href="https://www.djangoproject.com/">Django</a> and I need real-time updates, I usually reach for the <a href="https://channels.readthedocs.io/en/latest/">Django Channels</a> library. It’s great for full duplex communication and handles WebSockets really well. But let’s be honest—it can be a bit of a pain to set up, especially if you're not fully leveraging all its capabilities or you're not even in Django land. Plus, WebSockets can be flaky, and there's some overhead to deal with.</p>
<p>So I started looking for something lighter, and that's when I landed on <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Server-Sent Events (SSEs)</a>. They’re actually a solid alternative when all you need is one-way streaming from the server to the client. Simple, clean, and they just work for this kind of use case.</p>
<h2 id="server-sent-events-sses"><a class="zola-anchor" href="#server-sent-events-sses" aria-label="Anchor link for: server-sent-events-sses">Server-Sent Events (SSEs)</a></h2>
<p>Server-Sent Events (SSEs) are a neat way to push real-time updates from the server to the browser—without the client having to ping the server every few seconds. Instead of polling, the server just streams updates as they happen. Think live chat, news tickers, stock prices—basically any situation where you only need one-way updates, from server to client. But if you need two-way comms (like sending real-time data from the client too), then yeah, you’re back in WebSocket territory.</p>
<p>The nice part about SSEs is they run over plain old HTTP. That means no special protocol or fancy server setup required. Compare that with WebSockets, which need a full-duplex connection and something like Daphne to handle the WebSocket protocol. SSEs also have a few nice built-in features that WebSockets just don’t—like automatic reconnections, event IDs, and custom event types. That’s a win, especially on the frontend, since you don’t have to hand-roll a bunch of reconnect logic yourself.</p>
<p>Honestly, the biggest reason I started digging into SSEs was because of how simple they are—and the fact that they stay in the HTTP world. If you're curious how they really stack up against WebSockets, Germano Gabbianelli wrote a great <a href="https://germano.dev/sse-websockets/">post</a> on the topic that’s definitely worth a read.</p>
<h2 id="the-wire-protocol-how-sse-actually-works"><a class="zola-anchor" href="#the-wire-protocol-how-sse-actually-works" aria-label="Anchor link for: the-wire-protocol-how-sse-actually-works">The Wire Protocol (How SSE Actually Works)</a></h2>
<p>The SSE wire protocol is super simple and runs right on top of plain old HTTP. All the server has to do is send a stream of data with a specific structure. Here’s what a typical SSE response might look like:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#65737e;">// Source https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
</span><span style="color:#8fa1b3;">date_default_timezone_set</span><span>(&quot;</span><span style="color:#a3be8c;">America/New_York</span><span>&quot;);
</span><span style="color:#8fa1b3;">header</span><span>(&quot;</span><span style="color:#a3be8c;">X-Accel-Buffering: no</span><span>&quot;);
</span><span style="color:#8fa1b3;">header</span><span>(&quot;</span><span style="color:#a3be8c;">Content-Type: text/event-stream</span><span>&quot;);
</span><span style="color:#8fa1b3;">header</span><span>(&quot;</span><span style="color:#a3be8c;">Cache-Control: no-cache</span><span>&quot;);
</span><span>
</span><span style="color:#bf616a;">$counter </span><span>= </span><span style="color:#8fa1b3;">rand</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">10</span><span>);
</span><span style="color:#b48ead;">while </span><span>(</span><span style="color:#d08770;">true</span><span>) {
</span><span>  </span><span style="color:#65737e;">// Every second, send a &quot;ping&quot; event.
</span><span>
</span><span>  </span><span style="color:#bf616a;">echo </span><span>&quot;</span><span style="color:#a3be8c;">event: ping</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>  </span><span style="color:#bf616a;">$curDate </span><span>= </span><span style="color:#8fa1b3;">date</span><span>(</span><span style="color:#bf616a;">DATE_ISO8601</span><span>);
</span><span>  </span><span style="color:#bf616a;">echo </span><span>&#39;</span><span style="color:#a3be8c;">data: {&quot;time&quot;: &quot;</span><span>&#39; . </span><span style="color:#bf616a;">$curDate </span><span>. &#39;</span><span style="color:#a3be8c;">&quot;}</span><span>&#39;;
</span><span>  </span><span style="color:#bf616a;">echo </span><span>&quot;</span><span style="color:#96b5b4;">\n\n</span><span>&quot;;
</span><span>
</span><span>  </span><span style="color:#65737e;">// Send a simple message at random intervals.
</span><span>
</span><span>  </span><span style="color:#bf616a;">$counter</span><span>--;
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">$counter</span><span>) {
</span><span>    </span><span style="color:#bf616a;">echo </span><span>&#39;</span><span style="color:#a3be8c;">data: This is a message at time </span><span>&#39; . </span><span style="color:#bf616a;">$curDate </span><span>. &quot;</span><span style="color:#96b5b4;">\n\n</span><span>&quot;;
</span><span>    </span><span style="color:#bf616a;">$counter </span><span>= </span><span style="color:#8fa1b3;">rand</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">10</span><span>);
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#8fa1b3;">ob_get_contents</span><span>()) {
</span><span>      </span><span style="color:#8fa1b3;">ob_end_flush</span><span>();
</span><span>  }
</span><span>  </span><span style="color:#8fa1b3;">flush</span><span>();
</span><span>
</span><span>  </span><span style="color:#65737e;">// Break the loop if the client aborted the connection (closed the page)
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#8fa1b3;">connection_aborted</span><span>()) </span><span style="color:#b48ead;">break</span><span>;
</span><span>
</span><span>  </span><span style="color:#8fa1b3;">sleep</span><span>(</span><span style="color:#d08770;">1</span><span>);
</span><span>}
</span><span>
</span></code></pre>
<h2 id="a-simple-example"><a class="zola-anchor" href="#a-simple-example" aria-label="Anchor link for: a-simple-example">A simple example</a></h2>
<p>In this section, I’ll prop up a simple HTTP streaming server with <a href="https://fastapi.tiangolo.com/">FastAPI</a> and collect the events from the browser. Here’s the complete server implementation:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#b48ead;">import </span><span>asyncio
</span><span style="color:#b48ead;">from </span><span>typing </span><span style="color:#b48ead;">import </span><span>AsyncGenerator
</span><span>
</span><span style="color:#b48ead;">from </span><span>fastapi </span><span style="color:#b48ead;">import </span><span>FastAPI,Request
</span><span style="color:#b48ead;">from </span><span>fastapi.responses </span><span style="color:#b48ead;">import </span><span>HTMLResponse, StreamingResponse
</span><span style="color:#b48ead;">from </span><span>fastapi.templating </span><span style="color:#b48ead;">import </span><span>Jinja2Templates
</span><span>
</span><span>app = </span><span style="color:#bf616a;">FastAPI</span><span>()
</span><span>
</span><span style="color:#65737e;"># For the demo, we serve the html via FastAPI
</span><span>templates = </span><span style="color:#bf616a;">Jinja2Templates</span><span>(</span><span style="color:#bf616a;">directory</span><span>=&quot;</span><span style="color:#a3be8c;">templates</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=HTMLResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">index</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request):
</span><span>    </span><span style="color:#b48ead;">return </span><span>templates.</span><span style="color:#bf616a;">TemplateResponse</span><span>(</span><span style="color:#bf616a;">request</span><span>=request,</span><span style="color:#bf616a;">name</span><span>=&quot;</span><span style="color:#a3be8c;">index.html</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/stream</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=StreamingResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">stream</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request):
</span><span>    </span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">_stream</span><span>() -&gt; AsyncGenerator[str, </span><span style="color:#d08770;">None</span><span>]:
</span><span>        </span><span style="color:#b48ead;">for </span><span>number </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">11</span><span>):
</span><span>            </span><span style="color:#b48ead;">if await </span><span>request.</span><span style="color:#bf616a;">is_disconnected</span><span>():
</span><span>                </span><span style="color:#b48ead;">break
</span><span>            </span><span style="color:#b48ead;">yield f</span><span>&quot;</span><span style="color:#a3be8c;">event:stream</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">data:streaming number </span><span>{number}</span><span style="color:#96b5b4;">\n\n</span><span>&quot;
</span><span>            </span><span style="color:#b48ead;">await </span><span>asyncio.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span>            </span><span style="color:#b48ead;">if </span><span>number ==</span><span style="color:#d08770;">10</span><span>:
</span><span>                </span><span style="color:#b48ead;">break
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">StreamingResponse</span><span>(
</span><span>        </span><span style="color:#bf616a;">_stream</span><span>(), 
</span><span>        </span><span style="color:#bf616a;">media_type</span><span>=&quot;</span><span style="color:#a3be8c;">text/event-stream</span><span>&quot;,
</span><span>        </span><span style="color:#bf616a;">headers</span><span>={
</span><span>            &quot;</span><span style="color:#a3be8c;">Content-Type</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">text/event-stream</span><span>&quot;,
</span><span>            &quot;</span><span style="color:#a3be8c;">Access-Control-Allow-Origin</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">*</span><span>&quot;,
</span><span>            &quot;</span><span style="color:#a3be8c;">Cache-Control</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">no-cache</span><span>&quot;,}
</span><span>            )
</span><span>
</span><span>
</span><span style="color:#b48ead;">if </span><span>__name__ == &quot;</span><span style="color:#a3be8c;">__main__</span><span>&quot;:
</span><span>    </span><span style="color:#b48ead;">import </span><span>uvicorn
</span><span>    uvicorn.</span><span style="color:#bf616a;">run</span><span>(&quot;</span><span style="color:#a3be8c;">main:app</span><span>&quot;, </span><span style="color:#bf616a;">port</span><span>=</span><span style="color:#d08770;">8000</span><span>, </span><span style="color:#bf616a;">reload</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span></code></pre>
<p>The server exposes a /stream endpoint that will just continuously send data to any connected client. The stream function returns a StreamingResponse object that the framework uses to send SSE messages to the client. Internally, it defines an asynchronous generator function _stream which produces a sequence of messages that follows the SSE wire protocol and yields them line by line.</p>
<p>The index / page is there so that you can head over to it in your browser and paste the client-side code.</p>
<p>The content of index.html page:</p>
<pre data-lang="html" style="background-color:#2b303b;color:#c0c5ce;" class="language-html "><code class="language-html" data-lang="html"><span>&lt;!</span><span style="color:#b48ead;">DOCTYPE </span><span style="color:#d08770;">html</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">html </span><span style="color:#d08770;">lang</span><span>=&quot;</span><span style="color:#a3be8c;">en</span><span>&quot;&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">charset</span><span>=&quot;</span><span style="color:#a3be8c;">UTF-8</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">viewport</span><span>&quot; </span><span style="color:#d08770;">content</span><span>=&quot;</span><span style="color:#a3be8c;">width=device-width, initial-scale=1.0</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">title</span><span>&gt;SSE Fast API&lt;/</span><span style="color:#bf616a;">title</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">div </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">events</span><span>&quot;&gt;
</span><span>
</span><span>    &lt;/</span><span style="color:#bf616a;">div</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>        </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">eventSource </span><span>= new </span><span style="color:#bf616a;">EventSource</span><span>(&quot;</span><span style="color:#a3be8c;">/stream</span><span>&quot;);
</span><span>        </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onopen </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span>console.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">Connected to the server</span><span>&quot;);
</span><span>
</span><span>        </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">stream</span><span>&quot;, (event)</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>            </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">text </span><span>= document.</span><span style="color:#bf616a;">createElement</span><span>(&quot;</span><span style="color:#a3be8c;">p</span><span>&quot;)
</span><span>            </span><span style="color:#bf616a;">text</span><span>.innerText = </span><span style="color:#bf616a;">event</span><span>.data
</span><span>            document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.events</span><span>&quot;).</span><span style="color:#bf616a;">appendChild</span><span>(</span><span style="color:#bf616a;">text</span><span>)
</span><span>        })
</span><span>
</span><span>        </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onerror </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>            </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">close</span><span>()
</span><span>            </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">text </span><span>= document.</span><span style="color:#bf616a;">createElement</span><span>(&quot;</span><span style="color:#a3be8c;">p</span><span>&quot;)
</span><span>            </span><span style="color:#bf616a;">text</span><span>.innerText = &quot;</span><span style="color:#a3be8c;">Finish Streaming</span><span>&quot;
</span><span>            document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.events</span><span>&quot;).</span><span style="color:#bf616a;">appendChild</span><span>(</span><span style="color:#bf616a;">text</span><span>)
</span><span>        }
</span><span>    &lt;/</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">html</span><span>&gt;
</span></code></pre>
<h2 id="result"><a class="zola-anchor" href="#result" aria-label="Anchor link for: result">Result</a></h2>
<div align="center">
<img src="/sse-result-simple.gif"/>
</div>
<h2 id="real-world-scenario-background-task-progress-with-sse"><a class="zola-anchor" href="#real-world-scenario-background-task-progress-with-sse" aria-label="Anchor link for: real-world-scenario-background-task-progress-with-sse">Real-World Scenario: Background Task Progress with SSE</a></h2>
<p>Let’s walk through the scenario I mentioned earlier: you load a specific page in your browser, and that kicks off a long-running background task powered by Celery. While that task is doing its thing in the background, the server keeps the browser updated on its progress in real time.</p>
<p>As soon as the task wraps up, the server sends a final message letting the client know it's done, and the browser can update the DOM accordingly—maybe show a success message, refresh part of the UI, or whatever makes sense.</p>
<p>What’s nice here is that the communication is entirely one-way. The client kicks things off, and after that, it’s just the server pushing updates until the task completes. No need for polling. No need for bidirectional messaging. And that’s exactly where Server-Sent Events shine—SSE is a perfect fit for this kind of workflow.</p>
<p>To test it out, you’ll need to install a few dependencies. Here I use <a href="https://astral.sh/blog/uv">uv</a>, but you can pip install if you use pip:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">uv</span><span> add &#39;</span><span style="color:#a3be8c;">celery[redis]</span><span>&#39;
</span><span>&gt; 
</span><span style="color:#bf616a;">Resolved</span><span> 56 packages in 305ms
</span><span style="color:#bf616a;">Prepared</span><span> 2 packages in 109ms
</span><span style="color:#bf616a;">Installed</span><span> 14 packages in 17ms
</span><span> </span><span style="color:#bf616a;">+</span><span> amqp==5.3.1
</span><span> </span><span style="color:#bf616a;">+</span><span> billiard==4.2.1
</span><span> </span><span style="color:#bf616a;">+</span><span> celery==5.5.1
</span><span> </span><span style="color:#bf616a;">+</span><span> click-didyoumean==0.3.1
</span><span> </span><span style="color:#bf616a;">+</span><span> click-plugins==1.1.1
</span><span> </span><span style="color:#bf616a;">+</span><span> click-repl==0.3.0
</span><span> </span><span style="color:#bf616a;">+</span><span> kombu==5.5.3
</span><span> </span><span style="color:#bf616a;">+</span><span> prompt-toolkit==3.0.51
</span><span> </span><span style="color:#bf616a;">+</span><span> python-dateutil==2.9.0.post0
</span><span> </span><span style="color:#bf616a;">+</span><span> redis==5.2.1
</span><span> </span><span style="color:#bf616a;">+</span><span> six==1.17.0
</span><span> </span><span style="color:#bf616a;">+</span><span> tzdata==2025.2
</span><span> </span><span style="color:#bf616a;">+</span><span> vine==5.1.0
</span><span> </span><span style="color:#bf616a;">+</span><span> wcwidth==0.2.13
</span></code></pre>
<p>You’ll also need to set up a <a href="https://redis.io/">Redis</a> server that <a href="https://docs.celeryq.dev/en/stable/">Celery</a> will use for broker communication. If you have <a href="https://www.docker.com/">Docker</a> installed in your system, you can run the following command to start a Redis server:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">docker</span><span> run</span><span style="color:#bf616a;"> --name</span><span> dev-redis</span><span style="color:#bf616a;"> -d -h</span><span> localhost</span><span style="color:#bf616a;"> -p</span><span> 6379:6379 redis:alpine
</span></code></pre>
<p>The <code>main.py</code> contains the server implementation that looks like this:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#b48ead;">import </span><span>asyncio
</span><span style="color:#b48ead;">import </span><span>json
</span><span style="color:#b48ead;">import </span><span>time
</span><span style="color:#b48ead;">from </span><span>typing </span><span style="color:#b48ead;">import </span><span>AsyncGenerator
</span><span style="color:#b48ead;">from </span><span>functools </span><span style="color:#b48ead;">import </span><span>cache
</span><span>
</span><span style="color:#b48ead;">from </span><span>celery </span><span style="color:#b48ead;">import </span><span>Celery
</span><span>
</span><span style="color:#b48ead;">import </span><span>redis
</span><span style="color:#b48ead;">import </span><span>redis.asyncio </span><span style="color:#b48ead;">as </span><span>aredis
</span><span>
</span><span style="color:#b48ead;">from </span><span>fastapi </span><span style="color:#b48ead;">import </span><span>FastAPI,Request
</span><span style="color:#b48ead;">from </span><span>fastapi.responses </span><span style="color:#b48ead;">import </span><span>HTMLResponse, StreamingResponse
</span><span style="color:#b48ead;">from </span><span>fastapi.templating </span><span style="color:#b48ead;">import </span><span>Jinja2Templates
</span><span>
</span><span>app = </span><span style="color:#bf616a;">FastAPI</span><span>()
</span><span>celery_app = </span><span style="color:#bf616a;">Celery</span><span>(&quot;</span><span style="color:#a3be8c;">tasks</span><span>&quot;, </span><span style="color:#bf616a;">backend</span><span>=&quot;</span><span style="color:#a3be8c;">redis://</span><span>&quot;, </span><span style="color:#bf616a;">broker</span><span>=&quot;</span><span style="color:#a3be8c;">redis://</span><span>&quot;)
</span><span>
</span><span>
</span><span>@</span><span style="color:#bf616a;">cache
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get_async_client</span><span>() -&gt; aredis.Redis:
</span><span>    </span><span style="color:#b48ead;">return </span><span>aredis.</span><span style="color:#bf616a;">from_url</span><span>(&quot;</span><span style="color:#a3be8c;">redis://localhost:6379</span><span>&quot;)
</span><span>
</span><span>@</span><span style="color:#bf616a;">cache
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get_client</span><span>() -&gt; redis.Redis:
</span><span>    </span><span style="color:#b48ead;">return </span><span>redis.</span><span style="color:#bf616a;">from_url</span><span>(&quot;</span><span style="color:#a3be8c;">redis://localhost:6379</span><span>&quot;)
</span><span>
</span><span>
</span><span>@celery_app.</span><span style="color:#bf616a;">task</span><span>(</span><span style="color:#bf616a;">bind</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">very_long_job</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; str:
</span><span>    </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">get_client</span><span>() </span><span style="color:#b48ead;">as </span><span>client:
</span><span>        </span><span style="color:#b48ead;">for </span><span>number </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">101</span><span>):
</span><span>            client.</span><span style="color:#bf616a;">publish</span><span>(</span><span style="color:#bf616a;">self</span><span>.request.id, </span><span style="color:#bf616a;">str</span><span>(number))
</span><span>            time.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">0.5</span><span>)
</span><span>    client.</span><span style="color:#bf616a;">close</span><span>() 
</span><span>
</span><span style="color:#65737e;"># For the demo, we serve the html via FastAPI
</span><span>templates = </span><span style="color:#bf616a;">Jinja2Templates</span><span>(</span><span style="color:#bf616a;">directory</span><span>=&quot;</span><span style="color:#a3be8c;">templates</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=HTMLResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">index</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request):
</span><span>    </span><span style="color:#b48ead;">return </span><span>templates.</span><span style="color:#bf616a;">TemplateResponse</span><span>(</span><span style="color:#bf616a;">request</span><span>=request,</span><span style="color:#bf616a;">name</span><span>=&quot;</span><span style="color:#a3be8c;">index.html</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">post</span><span>(&quot;</span><span style="color:#a3be8c;">/</span><span>&quot;)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">start_job</span><span>():
</span><span>    task = very_long_job.</span><span style="color:#bf616a;">apply_async</span><span>(</span><span style="color:#bf616a;">queue</span><span>=&quot;</span><span style="color:#a3be8c;">default</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">return </span><span>{&quot;</span><span style="color:#a3be8c;">job_id</span><span>&quot;:task.id}
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/stream/</span><span style="color:#d08770;">{job_id}</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=StreamingResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">stream</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request, </span><span style="color:#bf616a;">job_id</span><span>:str):
</span><span>    </span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">_stream</span><span>() -&gt; AsyncGenerator[str, </span><span style="color:#d08770;">None</span><span>]:
</span><span>        </span><span style="color:#b48ead;">try</span><span>:
</span><span>            </span><span style="color:#b48ead;">async with </span><span style="color:#bf616a;">get_async_client</span><span>().</span><span style="color:#bf616a;">pubsub</span><span>() </span><span style="color:#b48ead;">as </span><span>pubsub:
</span><span>                </span><span style="color:#b48ead;">await </span><span>pubsub.</span><span style="color:#bf616a;">subscribe</span><span>(job_id)
</span><span>                </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>                    msg = </span><span style="color:#b48ead;">await </span><span>pubsub.</span><span style="color:#bf616a;">get_message</span><span>(</span><span style="color:#bf616a;">ignore_subscribe_messages</span><span>=</span><span style="color:#d08770;">True</span><span>, </span><span style="color:#bf616a;">timeout</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span>                    </span><span style="color:#b48ead;">if </span><span>msg is </span><span style="color:#d08770;">None</span><span>:
</span><span>                        </span><span style="color:#b48ead;">continue
</span><span>                    data = json.</span><span style="color:#bf616a;">loads</span><span>(msg[&quot;</span><span style="color:#a3be8c;">data</span><span>&quot;])
</span><span>
</span><span>                    </span><span style="color:#b48ead;">yield f</span><span>&quot;</span><span style="color:#a3be8c;">event:progress</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">data:</span><span>{data}</span><span style="color:#96b5b4;">\n\n</span><span>&quot;
</span><span>
</span><span>                    </span><span style="color:#b48ead;">if </span><span>data ==</span><span style="color:#d08770;">100</span><span>:
</span><span>                        </span><span style="color:#b48ead;">yield f</span><span>&quot;</span><span style="color:#a3be8c;">event:success</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">data:Job Succeeded</span><span style="color:#96b5b4;">\n\n</span><span>&quot;
</span><span>                        </span><span style="color:#b48ead;">break
</span><span>                    </span><span style="color:#b48ead;">if await </span><span>request.</span><span style="color:#bf616a;">is_disconnected</span><span>():
</span><span>                        </span><span style="color:#b48ead;">break
</span><span>
</span><span>        </span><span style="color:#b48ead;">except </span><span>asyncio.CancelledError:
</span><span>            </span><span style="color:#b48ead;">raise
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">StreamingResponse</span><span>(
</span><span>        </span><span style="color:#bf616a;">_stream</span><span>(), 
</span><span>        </span><span style="color:#bf616a;">media_type</span><span>=&quot;</span><span style="color:#a3be8c;">text/event-stream</span><span>&quot;,
</span><span>        </span><span style="color:#bf616a;">headers</span><span>={
</span><span>            &quot;</span><span style="color:#a3be8c;">Access-Control-Allow-Origin</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">*</span><span>&quot;,
</span><span>            &quot;</span><span style="color:#a3be8c;">Cache-Control</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">no-cache</span><span>&quot;,}
</span><span>            )
</span><span>
</span><span>
</span><span style="color:#b48ead;">if </span><span>__name__ == &quot;</span><span style="color:#a3be8c;">__main__</span><span>&quot;:
</span><span>    </span><span style="color:#b48ead;">import </span><span>uvicorn
</span><span>    uvicorn.</span><span style="color:#bf616a;">run</span><span>(&quot;</span><span style="color:#a3be8c;">main:app</span><span>&quot;, </span><span style="color:#bf616a;">port</span><span>=</span><span style="color:#d08770;">8000</span><span>, </span><span style="color:#bf616a;">reload</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span></code></pre>
<p>Here, first, we initialize a FastAPI app and set up Celery with Redis as both the broker and result backend. We also configure two Redis clients: one synchronous (used by the Celery worker) and one asynchronous (used within FastAPI for real-time message streaming).</p>
<p>Next, we define a Celery task called very_long_job that simulates a long-running background process. It loops from 1 to 100, and at each step, it publishes the current number to a Redis pub/sub channel named after the task's unique ID. This creates a real-time stream of progress updates.</p>
<p>The index route (/) serves a simple HTML page using Jinja2 templates. When a user submits a request (typically via a button or form), a POST call to / triggers the Celery task asynchronously. The response returns the job_id, which the frontend can use to track the progress.</p>
<p>Then, we expose a /stream/{job_id} route that leverages Server-Sent Events (SSE) to push updates to the frontend. This endpoint listens to the corresponding Redis pub/sub channel and streams progress messages (event: progress) to the client as they are published. These updates allow the frontend to dynamically show the status of the background task—such as updating a progress bar in real time.</p>
<p>To avoid resource leaks or infinite connections, the stream breaks if either the task reaches 100% completion or the client disconnects.</p>
<p>In short, this architecture cleanly separates concerns:</p>
<ul>
<li>
<p>Celery handles long-running logic without blocking the main app.</p>
</li>
<li>
<p>Redis pub/sub provides lightweight real-time messaging.</p>
</li>
<li>
<p>SSE pushes live updates to the frontend for a smooth user experience.</p>
</li>
</ul>
<p>This setup is perfect for use cases like video processing, data analysis, or any background work where users expect immediate feedback on progress.</p>
<p>The content of index.html is like this:</p>
<blockquote>
<p>I use <a href="https://bulma.io/">Bulma</a> to get some style</p>
</blockquote>
<pre data-lang="html" style="background-color:#2b303b;color:#c0c5ce;" class="language-html "><code class="language-html" data-lang="html"><span>&lt;!</span><span style="color:#b48ead;">DOCTYPE </span><span style="color:#d08770;">html</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">html </span><span style="color:#d08770;">lang</span><span>=&quot;</span><span style="color:#a3be8c;">en</span><span>&quot;&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">charset</span><span>=&quot;</span><span style="color:#a3be8c;">UTF-8</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">viewport</span><span>&quot; </span><span style="color:#d08770;">content</span><span>=&quot;</span><span style="color:#a3be8c;">width=device-width, initial-scale=1.0</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">link </span><span style="color:#d08770;">rel</span><span>=&quot;</span><span style="color:#a3be8c;">stylesheet</span><span>&quot; </span><span style="color:#d08770;">href</span><span>=&quot;</span><span style="color:#a3be8c;">https://cdn.jsdelivr.net/npm/bulma@1.0.2/css/bulma.min.css</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">title</span><span>&gt;SSE Fast API&lt;/</span><span style="color:#bf616a;">title</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">section </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">hero is-fullheight</span><span>&quot;&gt;
</span><span>        &lt;</span><span style="color:#bf616a;">div </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">hero-body</span><span>&quot;&gt;
</span><span>            &lt;</span><span style="color:#bf616a;">div </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">container has-text-centered</span><span>&quot;&gt;
</span><span>                &lt;</span><span style="color:#bf616a;">p </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">title</span><span>&quot;&gt;Processing Task ...&lt;/</span><span style="color:#bf616a;">p</span><span>&gt;
</span><span>                &lt;</span><span style="color:#bf616a;">progress </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">progress is-primary</span><span>&quot; </span><span style="color:#d08770;">min</span><span>=&quot;</span><span style="color:#a3be8c;">0</span><span>&quot; </span><span style="color:#d08770;">max</span><span>=&quot;</span><span style="color:#a3be8c;">100</span><span>&quot; </span><span style="color:#d08770;">value</span><span>=&quot;</span><span style="color:#a3be8c;">0</span><span>&quot;&gt;&lt;/</span><span style="color:#bf616a;">progress</span><span>&gt;
</span><span>                &lt;</span><span style="color:#bf616a;">button </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">button is-link</span><span>&quot;&gt;Start Task&lt;/</span><span style="color:#bf616a;">button</span><span>&gt;
</span><span>            &lt;/</span><span style="color:#bf616a;">div</span><span>&gt;
</span><span>        &lt;/</span><span style="color:#bf616a;">div</span><span>&gt;
</span><span>    &lt;/</span><span style="color:#bf616a;">section</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>        </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">btn </span><span>= document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.button</span><span>&quot;).</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">click</span><span>&quot;, () </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>
</span><span>            </span><span style="color:#bf616a;">fetch</span><span>(&quot;&quot;,{method:&#39;</span><span style="color:#a3be8c;">POST</span><span>&#39;})
</span><span>            .</span><span style="color:#bf616a;">then</span><span>(jsonResponse</span><span style="color:#b48ead;">=&gt;</span><span style="color:#bf616a;">jsonResponse</span><span>.</span><span style="color:#bf616a;">json</span><span>())
</span><span>            .</span><span style="color:#bf616a;">then</span><span>(data</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>                </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">jobId </span><span>= </span><span style="color:#bf616a;">data</span><span>.job_id;
</span><span>
</span><span>                </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">eventSource </span><span>= new </span><span style="color:#bf616a;">EventSource</span><span>(`</span><span style="color:#a3be8c;">/stream/</span><span>${</span><span style="color:#bf616a;">jobId</span><span>}`)
</span><span>                </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onopen </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span>console.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">Connected</span><span>&quot;);
</span><span>                </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onerror </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">close</span><span>()
</span><span>                </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">progress</span><span>&quot;, event</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>                    document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.progress</span><span>&quot;).value=</span><span style="color:#bf616a;">event</span><span>.data
</span><span>                })
</span><span>                </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">success</span><span>&quot;, event</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>                    document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.title</span><span>&quot;).textContent=</span><span style="color:#bf616a;">event</span><span>.data
</span><span>                    </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">close</span><span>()    
</span><span>                })
</span><span>                
</span><span>            })
</span><span>            
</span><span>        })
</span><span>    &lt;/</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">html</span><span>&gt;
</span></code></pre>
<p>This code defines a simple web page that allows users to start a background task and visually track its progress in real time. The interface includes a progress bar and a button to initiate the task. When the user clicks the button, the browser sends a request to the backend to launch the task. The server responds with a unique identifier for that task.</p>
<p>Once the task is started, the frontend opens a live connection to the server using Server-Sent Events (SSE), a technology that allows the server to push updates to the browser over time. Through this connection, the server sends periodic messages indicating the task’s current progress. These messages are used to update the progress bar, giving the user live feedback.</p>
<p>When the task reaches completion, the server sends a final message indicating success. The frontend then updates the page title to reflect that the task is done and closes the connection. Overall, the setup provides a seamless, real-time way for users to follow the execution of a long-running task without refreshing the page or constantly polling the server.</p>
<p>To run the Project:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">uvicorn</span><span> main:app</span><span style="color:#bf616a;"> --port</span><span> 8000</span><span style="color:#bf616a;"> --reload
</span><span>
</span></code></pre>
<p>On another terminal, start the celery workers:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">celery -A</span><span> main.celery_app worker</span><span style="color:#bf616a;"> -l</span><span> info</span><span style="color:#bf616a;"> -Q</span><span> default</span><span style="color:#bf616a;"> -c</span><span> 1
</span></code></pre>
<h2 id="result-overview"><a class="zola-anchor" href="#result-overview" aria-label="Anchor link for: result-overview">Result Overview</a></h2>
<div align="center">
<img src="/sse-final-results.gif"/>
</div>
Notice, how the server pushes the result of the task automatically once it finishes.
<h2 id="github-source"><a class="zola-anchor" href="#github-source" aria-label="Anchor link for: github-source">Github source</a></h2>
<p><a href="https://github.com/malnossi/sse-fastapi">SSE FastAPI</a></p>
<h2 id="final-words"><a class="zola-anchor" href="#final-words" aria-label="Anchor link for: final-words">Final Words</a></h2>
<p>Server-Sent Events (SSE) can be a great way to push real-time updates from the server to the client, but a lot of developers overlook key risks that come with using it. First, scalability is a major concern—each client keeps a connection open, which eats up server resources fast as your user count grows. Plus, browsers limit how many connections you can make per domain, so that’s another bottleneck.</p>
<p>Compatibility can also be tricky. Older browsers (like Internet Explorer) don’t support SSE, and some networks or proxies might block the open connection SSE needs to work. Then there’s reconnection—SSE will try to reconnect if it drops, but if you don’t handle it right on the server side, you might get duplicate or missing messages. Using message IDs or timestamps helps with that.</p>
<p>Security-wise, SSE runs over HTTP unless you secure it with HTTPS, so make sure to encrypt your streams and handle auth properly. Also, SSE only supports text data natively, so if you need to send binary data, you’ll have to encode it (e.g. base64), which isn’t ideal. In those cases, WebSockets might be a better fit.</p>
<p>Lastly, debugging SSE can be a pain—most tools don’t support it well.</p>
<p>Bottom line: SSE is useful, but it comes with caveats. Know what you’re getting into before relying on it for anything mission-critical.</p>

</div>
<!-- <div class="section">
  <div class="card">
    <div class="card-image">

    </div>
    <div class="card-content">
      <div class="level">
        <div class="level-item has-text-centered">
          <div>
            <h1 class="heading is-size-5"><strong>Pushing real-time updates to clients with Server-Sent Events (SSEs)</strong></h1>
            <div class="tags is-flex is-justify-content-center">
              
              <a class="tag is-link is-hoverable" href="/tags/python">#Python</a>
              
              <a class="tag is-link is-hoverable" href="/tags/fastapi">#FastApi</a>
              
              <a class="tag is-link is-hoverable" href="/tags/javascript">#Javascript</a>
              
            </div>
          </div>
        </div>
      </div>
      <div class="media">
        <div class="media-content">
          <span class="title is-size-6">Mohamed AL NOSSIRAT</span> |
          <time datetime="2025-04-17">17&#x2F;04&#x2F;2025</time>
          <hr />
        </div>

      </div>
      <div class="content has-text-justified">
        <h2 id="introduction"><a class="zola-anchor" href="#introduction" aria-label="Anchor link for: introduction">Introduction</a></h2>
<p>In multi-page web apps, there’s a pretty common flow that comes up:</p>
<p>A user loads a specific page or hits a button that kicks off a long-running task.
On the backend, a background worker grabs that task and starts processing it asynchronously.
Meanwhile, the page stays put—it shouldn't reload or block while all this is going on.
As the task runs, the server needs a way to keep the client updated with the status in real time.
Then once it’s done, the client should display a success or error message based on the result.</p>
<p>Now, the go-to tool when you need real-time, bidirectional communication is usually <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>. But in this case, it’s actually a one-way street: the client triggers something, and then it’s the server pushing updates back as the background job progresses.</p>
<p>Personally, when I’m working in <a href="https://www.djangoproject.com/">Django</a> and I need real-time updates, I usually reach for the <a href="https://channels.readthedocs.io/en/latest/">Django Channels</a> library. It’s great for full duplex communication and handles WebSockets really well. But let’s be honest—it can be a bit of a pain to set up, especially if you're not fully leveraging all its capabilities or you're not even in Django land. Plus, WebSockets can be flaky, and there's some overhead to deal with.</p>
<p>So I started looking for something lighter, and that's when I landed on <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Server-Sent Events (SSEs)</a>. They’re actually a solid alternative when all you need is one-way streaming from the server to the client. Simple, clean, and they just work for this kind of use case.</p>
<h2 id="server-sent-events-sses"><a class="zola-anchor" href="#server-sent-events-sses" aria-label="Anchor link for: server-sent-events-sses">Server-Sent Events (SSEs)</a></h2>
<p>Server-Sent Events (SSEs) are a neat way to push real-time updates from the server to the browser—without the client having to ping the server every few seconds. Instead of polling, the server just streams updates as they happen. Think live chat, news tickers, stock prices—basically any situation where you only need one-way updates, from server to client. But if you need two-way comms (like sending real-time data from the client too), then yeah, you’re back in WebSocket territory.</p>
<p>The nice part about SSEs is they run over plain old HTTP. That means no special protocol or fancy server setup required. Compare that with WebSockets, which need a full-duplex connection and something like Daphne to handle the WebSocket protocol. SSEs also have a few nice built-in features that WebSockets just don’t—like automatic reconnections, event IDs, and custom event types. That’s a win, especially on the frontend, since you don’t have to hand-roll a bunch of reconnect logic yourself.</p>
<p>Honestly, the biggest reason I started digging into SSEs was because of how simple they are—and the fact that they stay in the HTTP world. If you're curious how they really stack up against WebSockets, Germano Gabbianelli wrote a great <a href="https://germano.dev/sse-websockets/">post</a> on the topic that’s definitely worth a read.</p>
<h2 id="the-wire-protocol-how-sse-actually-works"><a class="zola-anchor" href="#the-wire-protocol-how-sse-actually-works" aria-label="Anchor link for: the-wire-protocol-how-sse-actually-works">The Wire Protocol (How SSE Actually Works)</a></h2>
<p>The SSE wire protocol is super simple and runs right on top of plain old HTTP. All the server has to do is send a stream of data with a specific structure. Here’s what a typical SSE response might look like:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#65737e;">// Source https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
</span><span style="color:#8fa1b3;">date_default_timezone_set</span><span>(&quot;</span><span style="color:#a3be8c;">America/New_York</span><span>&quot;);
</span><span style="color:#8fa1b3;">header</span><span>(&quot;</span><span style="color:#a3be8c;">X-Accel-Buffering: no</span><span>&quot;);
</span><span style="color:#8fa1b3;">header</span><span>(&quot;</span><span style="color:#a3be8c;">Content-Type: text/event-stream</span><span>&quot;);
</span><span style="color:#8fa1b3;">header</span><span>(&quot;</span><span style="color:#a3be8c;">Cache-Control: no-cache</span><span>&quot;);
</span><span>
</span><span style="color:#bf616a;">$counter </span><span>= </span><span style="color:#8fa1b3;">rand</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">10</span><span>);
</span><span style="color:#b48ead;">while </span><span>(</span><span style="color:#d08770;">true</span><span>) {
</span><span>  </span><span style="color:#65737e;">// Every second, send a &quot;ping&quot; event.
</span><span>
</span><span>  </span><span style="color:#bf616a;">echo </span><span>&quot;</span><span style="color:#a3be8c;">event: ping</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>  </span><span style="color:#bf616a;">$curDate </span><span>= </span><span style="color:#8fa1b3;">date</span><span>(</span><span style="color:#bf616a;">DATE_ISO8601</span><span>);
</span><span>  </span><span style="color:#bf616a;">echo </span><span>&#39;</span><span style="color:#a3be8c;">data: {&quot;time&quot;: &quot;</span><span>&#39; . </span><span style="color:#bf616a;">$curDate </span><span>. &#39;</span><span style="color:#a3be8c;">&quot;}</span><span>&#39;;
</span><span>  </span><span style="color:#bf616a;">echo </span><span>&quot;</span><span style="color:#96b5b4;">\n\n</span><span>&quot;;
</span><span>
</span><span>  </span><span style="color:#65737e;">// Send a simple message at random intervals.
</span><span>
</span><span>  </span><span style="color:#bf616a;">$counter</span><span>--;
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">$counter</span><span>) {
</span><span>    </span><span style="color:#bf616a;">echo </span><span>&#39;</span><span style="color:#a3be8c;">data: This is a message at time </span><span>&#39; . </span><span style="color:#bf616a;">$curDate </span><span>. &quot;</span><span style="color:#96b5b4;">\n\n</span><span>&quot;;
</span><span>    </span><span style="color:#bf616a;">$counter </span><span>= </span><span style="color:#8fa1b3;">rand</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">10</span><span>);
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#8fa1b3;">ob_get_contents</span><span>()) {
</span><span>      </span><span style="color:#8fa1b3;">ob_end_flush</span><span>();
</span><span>  }
</span><span>  </span><span style="color:#8fa1b3;">flush</span><span>();
</span><span>
</span><span>  </span><span style="color:#65737e;">// Break the loop if the client aborted the connection (closed the page)
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#8fa1b3;">connection_aborted</span><span>()) </span><span style="color:#b48ead;">break</span><span>;
</span><span>
</span><span>  </span><span style="color:#8fa1b3;">sleep</span><span>(</span><span style="color:#d08770;">1</span><span>);
</span><span>}
</span><span>
</span></code></pre>
<h2 id="a-simple-example"><a class="zola-anchor" href="#a-simple-example" aria-label="Anchor link for: a-simple-example">A simple example</a></h2>
<p>In this section, I’ll prop up a simple HTTP streaming server with <a href="https://fastapi.tiangolo.com/">FastAPI</a> and collect the events from the browser. Here’s the complete server implementation:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#b48ead;">import </span><span>asyncio
</span><span style="color:#b48ead;">from </span><span>typing </span><span style="color:#b48ead;">import </span><span>AsyncGenerator
</span><span>
</span><span style="color:#b48ead;">from </span><span>fastapi </span><span style="color:#b48ead;">import </span><span>FastAPI,Request
</span><span style="color:#b48ead;">from </span><span>fastapi.responses </span><span style="color:#b48ead;">import </span><span>HTMLResponse, StreamingResponse
</span><span style="color:#b48ead;">from </span><span>fastapi.templating </span><span style="color:#b48ead;">import </span><span>Jinja2Templates
</span><span>
</span><span>app = </span><span style="color:#bf616a;">FastAPI</span><span>()
</span><span>
</span><span style="color:#65737e;"># For the demo, we serve the html via FastAPI
</span><span>templates = </span><span style="color:#bf616a;">Jinja2Templates</span><span>(</span><span style="color:#bf616a;">directory</span><span>=&quot;</span><span style="color:#a3be8c;">templates</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=HTMLResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">index</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request):
</span><span>    </span><span style="color:#b48ead;">return </span><span>templates.</span><span style="color:#bf616a;">TemplateResponse</span><span>(</span><span style="color:#bf616a;">request</span><span>=request,</span><span style="color:#bf616a;">name</span><span>=&quot;</span><span style="color:#a3be8c;">index.html</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/stream</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=StreamingResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">stream</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request):
</span><span>    </span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">_stream</span><span>() -&gt; AsyncGenerator[str, </span><span style="color:#d08770;">None</span><span>]:
</span><span>        </span><span style="color:#b48ead;">for </span><span>number </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">11</span><span>):
</span><span>            </span><span style="color:#b48ead;">if await </span><span>request.</span><span style="color:#bf616a;">is_disconnected</span><span>():
</span><span>                </span><span style="color:#b48ead;">break
</span><span>            </span><span style="color:#b48ead;">yield f</span><span>&quot;</span><span style="color:#a3be8c;">event:stream</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">data:streaming number </span><span>{number}</span><span style="color:#96b5b4;">\n\n</span><span>&quot;
</span><span>            </span><span style="color:#b48ead;">await </span><span>asyncio.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span>            </span><span style="color:#b48ead;">if </span><span>number ==</span><span style="color:#d08770;">10</span><span>:
</span><span>                </span><span style="color:#b48ead;">break
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">StreamingResponse</span><span>(
</span><span>        </span><span style="color:#bf616a;">_stream</span><span>(), 
</span><span>        </span><span style="color:#bf616a;">media_type</span><span>=&quot;</span><span style="color:#a3be8c;">text/event-stream</span><span>&quot;,
</span><span>        </span><span style="color:#bf616a;">headers</span><span>={
</span><span>            &quot;</span><span style="color:#a3be8c;">Content-Type</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">text/event-stream</span><span>&quot;,
</span><span>            &quot;</span><span style="color:#a3be8c;">Access-Control-Allow-Origin</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">*</span><span>&quot;,
</span><span>            &quot;</span><span style="color:#a3be8c;">Cache-Control</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">no-cache</span><span>&quot;,}
</span><span>            )
</span><span>
</span><span>
</span><span style="color:#b48ead;">if </span><span>__name__ == &quot;</span><span style="color:#a3be8c;">__main__</span><span>&quot;:
</span><span>    </span><span style="color:#b48ead;">import </span><span>uvicorn
</span><span>    uvicorn.</span><span style="color:#bf616a;">run</span><span>(&quot;</span><span style="color:#a3be8c;">main:app</span><span>&quot;, </span><span style="color:#bf616a;">port</span><span>=</span><span style="color:#d08770;">8000</span><span>, </span><span style="color:#bf616a;">reload</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span></code></pre>
<p>The server exposes a /stream endpoint that will just continuously send data to any connected client. The stream function returns a StreamingResponse object that the framework uses to send SSE messages to the client. Internally, it defines an asynchronous generator function _stream which produces a sequence of messages that follows the SSE wire protocol and yields them line by line.</p>
<p>The index / page is there so that you can head over to it in your browser and paste the client-side code.</p>
<p>The content of index.html page:</p>
<pre data-lang="html" style="background-color:#2b303b;color:#c0c5ce;" class="language-html "><code class="language-html" data-lang="html"><span>&lt;!</span><span style="color:#b48ead;">DOCTYPE </span><span style="color:#d08770;">html</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">html </span><span style="color:#d08770;">lang</span><span>=&quot;</span><span style="color:#a3be8c;">en</span><span>&quot;&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">charset</span><span>=&quot;</span><span style="color:#a3be8c;">UTF-8</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">viewport</span><span>&quot; </span><span style="color:#d08770;">content</span><span>=&quot;</span><span style="color:#a3be8c;">width=device-width, initial-scale=1.0</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">title</span><span>&gt;SSE Fast API&lt;/</span><span style="color:#bf616a;">title</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">div </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">events</span><span>&quot;&gt;
</span><span>
</span><span>    &lt;/</span><span style="color:#bf616a;">div</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>        </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">eventSource </span><span>= new </span><span style="color:#bf616a;">EventSource</span><span>(&quot;</span><span style="color:#a3be8c;">/stream</span><span>&quot;);
</span><span>        </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onopen </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span>console.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">Connected to the server</span><span>&quot;);
</span><span>
</span><span>        </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">stream</span><span>&quot;, (event)</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>            </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">text </span><span>= document.</span><span style="color:#bf616a;">createElement</span><span>(&quot;</span><span style="color:#a3be8c;">p</span><span>&quot;)
</span><span>            </span><span style="color:#bf616a;">text</span><span>.innerText = </span><span style="color:#bf616a;">event</span><span>.data
</span><span>            document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.events</span><span>&quot;).</span><span style="color:#bf616a;">appendChild</span><span>(</span><span style="color:#bf616a;">text</span><span>)
</span><span>        })
</span><span>
</span><span>        </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onerror </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>            </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">close</span><span>()
</span><span>            </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">text </span><span>= document.</span><span style="color:#bf616a;">createElement</span><span>(&quot;</span><span style="color:#a3be8c;">p</span><span>&quot;)
</span><span>            </span><span style="color:#bf616a;">text</span><span>.innerText = &quot;</span><span style="color:#a3be8c;">Finish Streaming</span><span>&quot;
</span><span>            document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.events</span><span>&quot;).</span><span style="color:#bf616a;">appendChild</span><span>(</span><span style="color:#bf616a;">text</span><span>)
</span><span>        }
</span><span>    &lt;/</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">html</span><span>&gt;
</span></code></pre>
<h2 id="result"><a class="zola-anchor" href="#result" aria-label="Anchor link for: result">Result</a></h2>
<div align="center">
<img src="/sse-result-simple.gif"/>
</div>
<h2 id="real-world-scenario-background-task-progress-with-sse"><a class="zola-anchor" href="#real-world-scenario-background-task-progress-with-sse" aria-label="Anchor link for: real-world-scenario-background-task-progress-with-sse">Real-World Scenario: Background Task Progress with SSE</a></h2>
<p>Let’s walk through the scenario I mentioned earlier: you load a specific page in your browser, and that kicks off a long-running background task powered by Celery. While that task is doing its thing in the background, the server keeps the browser updated on its progress in real time.</p>
<p>As soon as the task wraps up, the server sends a final message letting the client know it's done, and the browser can update the DOM accordingly—maybe show a success message, refresh part of the UI, or whatever makes sense.</p>
<p>What’s nice here is that the communication is entirely one-way. The client kicks things off, and after that, it’s just the server pushing updates until the task completes. No need for polling. No need for bidirectional messaging. And that’s exactly where Server-Sent Events shine—SSE is a perfect fit for this kind of workflow.</p>
<p>To test it out, you’ll need to install a few dependencies. Here I use <a href="https://astral.sh/blog/uv">uv</a>, but you can pip install if you use pip:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">uv</span><span> add &#39;</span><span style="color:#a3be8c;">celery[redis]</span><span>&#39;
</span><span>&gt; 
</span><span style="color:#bf616a;">Resolved</span><span> 56 packages in 305ms
</span><span style="color:#bf616a;">Prepared</span><span> 2 packages in 109ms
</span><span style="color:#bf616a;">Installed</span><span> 14 packages in 17ms
</span><span> </span><span style="color:#bf616a;">+</span><span> amqp==5.3.1
</span><span> </span><span style="color:#bf616a;">+</span><span> billiard==4.2.1
</span><span> </span><span style="color:#bf616a;">+</span><span> celery==5.5.1
</span><span> </span><span style="color:#bf616a;">+</span><span> click-didyoumean==0.3.1
</span><span> </span><span style="color:#bf616a;">+</span><span> click-plugins==1.1.1
</span><span> </span><span style="color:#bf616a;">+</span><span> click-repl==0.3.0
</span><span> </span><span style="color:#bf616a;">+</span><span> kombu==5.5.3
</span><span> </span><span style="color:#bf616a;">+</span><span> prompt-toolkit==3.0.51
</span><span> </span><span style="color:#bf616a;">+</span><span> python-dateutil==2.9.0.post0
</span><span> </span><span style="color:#bf616a;">+</span><span> redis==5.2.1
</span><span> </span><span style="color:#bf616a;">+</span><span> six==1.17.0
</span><span> </span><span style="color:#bf616a;">+</span><span> tzdata==2025.2
</span><span> </span><span style="color:#bf616a;">+</span><span> vine==5.1.0
</span><span> </span><span style="color:#bf616a;">+</span><span> wcwidth==0.2.13
</span></code></pre>
<p>You’ll also need to set up a <a href="https://redis.io/">Redis</a> server that <a href="https://docs.celeryq.dev/en/stable/">Celery</a> will use for broker communication. If you have <a href="https://www.docker.com/">Docker</a> installed in your system, you can run the following command to start a Redis server:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">docker</span><span> run</span><span style="color:#bf616a;"> --name</span><span> dev-redis</span><span style="color:#bf616a;"> -d -h</span><span> localhost</span><span style="color:#bf616a;"> -p</span><span> 6379:6379 redis:alpine
</span></code></pre>
<p>The <code>main.py</code> contains the server implementation that looks like this:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#b48ead;">import </span><span>asyncio
</span><span style="color:#b48ead;">import </span><span>json
</span><span style="color:#b48ead;">import </span><span>time
</span><span style="color:#b48ead;">from </span><span>typing </span><span style="color:#b48ead;">import </span><span>AsyncGenerator
</span><span style="color:#b48ead;">from </span><span>functools </span><span style="color:#b48ead;">import </span><span>cache
</span><span>
</span><span style="color:#b48ead;">from </span><span>celery </span><span style="color:#b48ead;">import </span><span>Celery
</span><span>
</span><span style="color:#b48ead;">import </span><span>redis
</span><span style="color:#b48ead;">import </span><span>redis.asyncio </span><span style="color:#b48ead;">as </span><span>aredis
</span><span>
</span><span style="color:#b48ead;">from </span><span>fastapi </span><span style="color:#b48ead;">import </span><span>FastAPI,Request
</span><span style="color:#b48ead;">from </span><span>fastapi.responses </span><span style="color:#b48ead;">import </span><span>HTMLResponse, StreamingResponse
</span><span style="color:#b48ead;">from </span><span>fastapi.templating </span><span style="color:#b48ead;">import </span><span>Jinja2Templates
</span><span>
</span><span>app = </span><span style="color:#bf616a;">FastAPI</span><span>()
</span><span>celery_app = </span><span style="color:#bf616a;">Celery</span><span>(&quot;</span><span style="color:#a3be8c;">tasks</span><span>&quot;, </span><span style="color:#bf616a;">backend</span><span>=&quot;</span><span style="color:#a3be8c;">redis://</span><span>&quot;, </span><span style="color:#bf616a;">broker</span><span>=&quot;</span><span style="color:#a3be8c;">redis://</span><span>&quot;)
</span><span>
</span><span>
</span><span>@</span><span style="color:#bf616a;">cache
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get_async_client</span><span>() -&gt; aredis.Redis:
</span><span>    </span><span style="color:#b48ead;">return </span><span>aredis.</span><span style="color:#bf616a;">from_url</span><span>(&quot;</span><span style="color:#a3be8c;">redis://localhost:6379</span><span>&quot;)
</span><span>
</span><span>@</span><span style="color:#bf616a;">cache
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get_client</span><span>() -&gt; redis.Redis:
</span><span>    </span><span style="color:#b48ead;">return </span><span>redis.</span><span style="color:#bf616a;">from_url</span><span>(&quot;</span><span style="color:#a3be8c;">redis://localhost:6379</span><span>&quot;)
</span><span>
</span><span>
</span><span>@celery_app.</span><span style="color:#bf616a;">task</span><span>(</span><span style="color:#bf616a;">bind</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">very_long_job</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; str:
</span><span>    </span><span style="color:#b48ead;">with </span><span style="color:#bf616a;">get_client</span><span>() </span><span style="color:#b48ead;">as </span><span>client:
</span><span>        </span><span style="color:#b48ead;">for </span><span>number </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">101</span><span>):
</span><span>            client.</span><span style="color:#bf616a;">publish</span><span>(</span><span style="color:#bf616a;">self</span><span>.request.id, </span><span style="color:#bf616a;">str</span><span>(number))
</span><span>            time.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">0.5</span><span>)
</span><span>    client.</span><span style="color:#bf616a;">close</span><span>() 
</span><span>
</span><span style="color:#65737e;"># For the demo, we serve the html via FastAPI
</span><span>templates = </span><span style="color:#bf616a;">Jinja2Templates</span><span>(</span><span style="color:#bf616a;">directory</span><span>=&quot;</span><span style="color:#a3be8c;">templates</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=HTMLResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">index</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request):
</span><span>    </span><span style="color:#b48ead;">return </span><span>templates.</span><span style="color:#bf616a;">TemplateResponse</span><span>(</span><span style="color:#bf616a;">request</span><span>=request,</span><span style="color:#bf616a;">name</span><span>=&quot;</span><span style="color:#a3be8c;">index.html</span><span>&quot;)
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">post</span><span>(&quot;</span><span style="color:#a3be8c;">/</span><span>&quot;)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">start_job</span><span>():
</span><span>    task = very_long_job.</span><span style="color:#bf616a;">apply_async</span><span>(</span><span style="color:#bf616a;">queue</span><span>=&quot;</span><span style="color:#a3be8c;">default</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">return </span><span>{&quot;</span><span style="color:#a3be8c;">job_id</span><span>&quot;:task.id}
</span><span>
</span><span>@app.</span><span style="color:#bf616a;">get</span><span>(&quot;</span><span style="color:#a3be8c;">/stream/</span><span style="color:#d08770;">{job_id}</span><span>&quot;, </span><span style="color:#bf616a;">response_class</span><span>=StreamingResponse)
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">stream</span><span>(</span><span style="color:#bf616a;">request</span><span>:Request, </span><span style="color:#bf616a;">job_id</span><span>:str):
</span><span>    </span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">_stream</span><span>() -&gt; AsyncGenerator[str, </span><span style="color:#d08770;">None</span><span>]:
</span><span>        </span><span style="color:#b48ead;">try</span><span>:
</span><span>            </span><span style="color:#b48ead;">async with </span><span style="color:#bf616a;">get_async_client</span><span>().</span><span style="color:#bf616a;">pubsub</span><span>() </span><span style="color:#b48ead;">as </span><span>pubsub:
</span><span>                </span><span style="color:#b48ead;">await </span><span>pubsub.</span><span style="color:#bf616a;">subscribe</span><span>(job_id)
</span><span>                </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>                    msg = </span><span style="color:#b48ead;">await </span><span>pubsub.</span><span style="color:#bf616a;">get_message</span><span>(</span><span style="color:#bf616a;">ignore_subscribe_messages</span><span>=</span><span style="color:#d08770;">True</span><span>, </span><span style="color:#bf616a;">timeout</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span>                    </span><span style="color:#b48ead;">if </span><span>msg is </span><span style="color:#d08770;">None</span><span>:
</span><span>                        </span><span style="color:#b48ead;">continue
</span><span>                    data = json.</span><span style="color:#bf616a;">loads</span><span>(msg[&quot;</span><span style="color:#a3be8c;">data</span><span>&quot;])
</span><span>
</span><span>                    </span><span style="color:#b48ead;">yield f</span><span>&quot;</span><span style="color:#a3be8c;">event:progress</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">data:</span><span>{data}</span><span style="color:#96b5b4;">\n\n</span><span>&quot;
</span><span>
</span><span>                    </span><span style="color:#b48ead;">if </span><span>data ==</span><span style="color:#d08770;">100</span><span>:
</span><span>                        </span><span style="color:#b48ead;">yield f</span><span>&quot;</span><span style="color:#a3be8c;">event:success</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">data:Job Succeeded</span><span style="color:#96b5b4;">\n\n</span><span>&quot;
</span><span>                        </span><span style="color:#b48ead;">break
</span><span>                    </span><span style="color:#b48ead;">if await </span><span>request.</span><span style="color:#bf616a;">is_disconnected</span><span>():
</span><span>                        </span><span style="color:#b48ead;">break
</span><span>
</span><span>        </span><span style="color:#b48ead;">except </span><span>asyncio.CancelledError:
</span><span>            </span><span style="color:#b48ead;">raise
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">StreamingResponse</span><span>(
</span><span>        </span><span style="color:#bf616a;">_stream</span><span>(), 
</span><span>        </span><span style="color:#bf616a;">media_type</span><span>=&quot;</span><span style="color:#a3be8c;">text/event-stream</span><span>&quot;,
</span><span>        </span><span style="color:#bf616a;">headers</span><span>={
</span><span>            &quot;</span><span style="color:#a3be8c;">Access-Control-Allow-Origin</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">*</span><span>&quot;,
</span><span>            &quot;</span><span style="color:#a3be8c;">Cache-Control</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">no-cache</span><span>&quot;,}
</span><span>            )
</span><span>
</span><span>
</span><span style="color:#b48ead;">if </span><span>__name__ == &quot;</span><span style="color:#a3be8c;">__main__</span><span>&quot;:
</span><span>    </span><span style="color:#b48ead;">import </span><span>uvicorn
</span><span>    uvicorn.</span><span style="color:#bf616a;">run</span><span>(&quot;</span><span style="color:#a3be8c;">main:app</span><span>&quot;, </span><span style="color:#bf616a;">port</span><span>=</span><span style="color:#d08770;">8000</span><span>, </span><span style="color:#bf616a;">reload</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span></code></pre>
<p>Here, first, we initialize a FastAPI app and set up Celery with Redis as both the broker and result backend. We also configure two Redis clients: one synchronous (used by the Celery worker) and one asynchronous (used within FastAPI for real-time message streaming).</p>
<p>Next, we define a Celery task called very_long_job that simulates a long-running background process. It loops from 1 to 100, and at each step, it publishes the current number to a Redis pub/sub channel named after the task's unique ID. This creates a real-time stream of progress updates.</p>
<p>The index route (/) serves a simple HTML page using Jinja2 templates. When a user submits a request (typically via a button or form), a POST call to / triggers the Celery task asynchronously. The response returns the job_id, which the frontend can use to track the progress.</p>
<p>Then, we expose a /stream/{job_id} route that leverages Server-Sent Events (SSE) to push updates to the frontend. This endpoint listens to the corresponding Redis pub/sub channel and streams progress messages (event: progress) to the client as they are published. These updates allow the frontend to dynamically show the status of the background task—such as updating a progress bar in real time.</p>
<p>To avoid resource leaks or infinite connections, the stream breaks if either the task reaches 100% completion or the client disconnects.</p>
<p>In short, this architecture cleanly separates concerns:</p>
<ul>
<li>
<p>Celery handles long-running logic without blocking the main app.</p>
</li>
<li>
<p>Redis pub/sub provides lightweight real-time messaging.</p>
</li>
<li>
<p>SSE pushes live updates to the frontend for a smooth user experience.</p>
</li>
</ul>
<p>This setup is perfect for use cases like video processing, data analysis, or any background work where users expect immediate feedback on progress.</p>
<p>The content of index.html is like this:</p>
<blockquote>
<p>I use <a href="https://bulma.io/">Bulma</a> to get some style</p>
</blockquote>
<pre data-lang="html" style="background-color:#2b303b;color:#c0c5ce;" class="language-html "><code class="language-html" data-lang="html"><span>&lt;!</span><span style="color:#b48ead;">DOCTYPE </span><span style="color:#d08770;">html</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">html </span><span style="color:#d08770;">lang</span><span>=&quot;</span><span style="color:#a3be8c;">en</span><span>&quot;&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">charset</span><span>=&quot;</span><span style="color:#a3be8c;">UTF-8</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">viewport</span><span>&quot; </span><span style="color:#d08770;">content</span><span>=&quot;</span><span style="color:#a3be8c;">width=device-width, initial-scale=1.0</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">link </span><span style="color:#d08770;">rel</span><span>=&quot;</span><span style="color:#a3be8c;">stylesheet</span><span>&quot; </span><span style="color:#d08770;">href</span><span>=&quot;</span><span style="color:#a3be8c;">https://cdn.jsdelivr.net/npm/bulma@1.0.2/css/bulma.min.css</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">title</span><span>&gt;SSE Fast API&lt;/</span><span style="color:#bf616a;">title</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">section </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">hero is-fullheight</span><span>&quot;&gt;
</span><span>        &lt;</span><span style="color:#bf616a;">div </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">hero-body</span><span>&quot;&gt;
</span><span>            &lt;</span><span style="color:#bf616a;">div </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">container has-text-centered</span><span>&quot;&gt;
</span><span>                &lt;</span><span style="color:#bf616a;">p </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">title</span><span>&quot;&gt;Processing Task ...&lt;/</span><span style="color:#bf616a;">p</span><span>&gt;
</span><span>                &lt;</span><span style="color:#bf616a;">progress </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">progress is-primary</span><span>&quot; </span><span style="color:#d08770;">min</span><span>=&quot;</span><span style="color:#a3be8c;">0</span><span>&quot; </span><span style="color:#d08770;">max</span><span>=&quot;</span><span style="color:#a3be8c;">100</span><span>&quot; </span><span style="color:#d08770;">value</span><span>=&quot;</span><span style="color:#a3be8c;">0</span><span>&quot;&gt;&lt;/</span><span style="color:#bf616a;">progress</span><span>&gt;
</span><span>                &lt;</span><span style="color:#bf616a;">button </span><span style="color:#d08770;">class</span><span>=&quot;</span><span style="color:#a3be8c;">button is-link</span><span>&quot;&gt;Start Task&lt;/</span><span style="color:#bf616a;">button</span><span>&gt;
</span><span>            &lt;/</span><span style="color:#bf616a;">div</span><span>&gt;
</span><span>        &lt;/</span><span style="color:#bf616a;">div</span><span>&gt;
</span><span>    &lt;/</span><span style="color:#bf616a;">section</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>        </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">btn </span><span>= document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.button</span><span>&quot;).</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">click</span><span>&quot;, () </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>
</span><span>            </span><span style="color:#bf616a;">fetch</span><span>(&quot;&quot;,{method:&#39;</span><span style="color:#a3be8c;">POST</span><span>&#39;})
</span><span>            .</span><span style="color:#bf616a;">then</span><span>(jsonResponse</span><span style="color:#b48ead;">=&gt;</span><span style="color:#bf616a;">jsonResponse</span><span>.</span><span style="color:#bf616a;">json</span><span>())
</span><span>            .</span><span style="color:#bf616a;">then</span><span>(data</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>                </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">jobId </span><span>= </span><span style="color:#bf616a;">data</span><span>.job_id;
</span><span>
</span><span>                </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">eventSource </span><span>= new </span><span style="color:#bf616a;">EventSource</span><span>(`</span><span style="color:#a3be8c;">/stream/</span><span>${</span><span style="color:#bf616a;">jobId</span><span>}`)
</span><span>                </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onopen </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span>console.</span><span style="color:#96b5b4;">log</span><span>(&quot;</span><span style="color:#a3be8c;">Connected</span><span>&quot;);
</span><span>                </span><span style="color:#ebcb8b;">eventSource</span><span>.</span><span style="color:#bf616a;">onerror </span><span>= () </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">close</span><span>()
</span><span>                </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">progress</span><span>&quot;, event</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>                    document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.progress</span><span>&quot;).value=</span><span style="color:#bf616a;">event</span><span>.data
</span><span>                })
</span><span>                </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">success</span><span>&quot;, event</span><span style="color:#b48ead;">=&gt;</span><span>{
</span><span>                    document.</span><span style="color:#bf616a;">querySelector</span><span>(&quot;</span><span style="color:#a3be8c;">.title</span><span>&quot;).textContent=</span><span style="color:#bf616a;">event</span><span>.data
</span><span>                    </span><span style="color:#bf616a;">eventSource</span><span>.</span><span style="color:#bf616a;">close</span><span>()    
</span><span>                })
</span><span>                
</span><span>            })
</span><span>            
</span><span>        })
</span><span>    &lt;/</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">html</span><span>&gt;
</span></code></pre>
<p>This code defines a simple web page that allows users to start a background task and visually track its progress in real time. The interface includes a progress bar and a button to initiate the task. When the user clicks the button, the browser sends a request to the backend to launch the task. The server responds with a unique identifier for that task.</p>
<p>Once the task is started, the frontend opens a live connection to the server using Server-Sent Events (SSE), a technology that allows the server to push updates to the browser over time. Through this connection, the server sends periodic messages indicating the task’s current progress. These messages are used to update the progress bar, giving the user live feedback.</p>
<p>When the task reaches completion, the server sends a final message indicating success. The frontend then updates the page title to reflect that the task is done and closes the connection. Overall, the setup provides a seamless, real-time way for users to follow the execution of a long-running task without refreshing the page or constantly polling the server.</p>
<p>To run the Project:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">uvicorn</span><span> main:app</span><span style="color:#bf616a;"> --port</span><span> 8000</span><span style="color:#bf616a;"> --reload
</span><span>
</span></code></pre>
<p>On another terminal, start the celery workers:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">celery -A</span><span> main.celery_app worker</span><span style="color:#bf616a;"> -l</span><span> info</span><span style="color:#bf616a;"> -Q</span><span> default</span><span style="color:#bf616a;"> -c</span><span> 1
</span></code></pre>
<h2 id="result-overview"><a class="zola-anchor" href="#result-overview" aria-label="Anchor link for: result-overview">Result Overview</a></h2>
<div align="center">
<img src="/sse-final-results.gif"/>
</div>
Notice, how the server pushes the result of the task automatically once it finishes.
<h2 id="github-source"><a class="zola-anchor" href="#github-source" aria-label="Anchor link for: github-source">Github source</a></h2>
<p><a href="https://github.com/malnossi/sse-fastapi">SSE FastAPI</a></p>
<h2 id="final-words"><a class="zola-anchor" href="#final-words" aria-label="Anchor link for: final-words">Final Words</a></h2>
<p>Server-Sent Events (SSE) can be a great way to push real-time updates from the server to the client, but a lot of developers overlook key risks that come with using it. First, scalability is a major concern—each client keeps a connection open, which eats up server resources fast as your user count grows. Plus, browsers limit how many connections you can make per domain, so that’s another bottleneck.</p>
<p>Compatibility can also be tricky. Older browsers (like Internet Explorer) don’t support SSE, and some networks or proxies might block the open connection SSE needs to work. Then there’s reconnection—SSE will try to reconnect if it drops, but if you don’t handle it right on the server side, you might get duplicate or missing messages. Using message IDs or timestamps helps with that.</p>
<p>Security-wise, SSE runs over HTTP unless you secure it with HTTPS, so make sure to encrypt your streams and handle auth properly. Also, SSE only supports text data natively, so if you need to send binary data, you’ll have to encode it (e.g. base64), which isn’t ideal. In those cases, WebSockets might be a better fit.</p>
<p>Lastly, debugging SSE can be a pain—most tools don’t support it well.</p>
<p>Bottom line: SSE is useful, but it comes with caveats. Know what you’re getting into before relying on it for anything mission-critical.</p>

      </div>
    </div>
  </div>
</div> -->

    </main>

    <script lang="js" src='https://malnossi.github.io/script.js'></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8LBRDGLXJV" defer></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-8LBRDGLXJV');
    </script>
</body>

</html>